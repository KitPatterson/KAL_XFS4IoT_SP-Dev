/***********************************************************************************************\
 * (C) KAL ATM Software GmbH, 2021
 * KAL ATM Software GmbH licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
\***********************************************************************************************/

#include "pch.h"
#include "CppUnitTest.h"
#include "EndToEndSecurity.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

extern "C" void Log(char const* const Message)
{
    Logger::WriteMessage( Message );
};

extern "C" void FatalError(char const* const Message)
{
    using namespace Microsoft::VisualStudio::CppUnitTestFramework;
    Assert::Fail(ToString(Message).c_str());
}

namespace EndToEndSecurityTest
{
    TEST_CLASS(ValidateTokenTest)
    {
    public:
        
        TEST_METHOD(TokenMinLength)
        {
            char const testToken[] = "NONCE=1,TOKENFORMAT=1,TOKENLENGTH=0164,HMACSHA256=CB735612FD6141213C2827FB5A6A4F4846D7A7347B15434916FEA6AC16F3D2F2";
            auto result = ValidateToken( testToken, sizeof(testToken)  );
            Assert::AreEqual(result, true);
        }
        TEST_METHOD(TokenTooShort)
        {
            // HMAC one character too short. 
            char const testToken[] = "NONCE=1,TOKENFORMAT=1,TOKENLENGTH=0163,HMACSHA256=CB735612FD6141213C2827FB5A6A4F4846D7A7347B15434916FEA6AC16F3D2F";
            auto result = ValidateToken( testToken, sizeof(testToken)  );
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(TokenVeryLong)
        {
            // Maximum token length = 1024 bytes
            //                        1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
            char const testToken[] = "NONCE=1,TOKENFORMAT=1,TOKENLENGTH=1024,X=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" // 100
                                     "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222" // 200
                                     "3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333" // 300
                                     "4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444" // 400
                                     "5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555" // 500
                                     "6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666" // 600
                                     "7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777" // 700
                                     "8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888" // 800
                                     "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999" // 900
                                     "000000000000000000000000000000000000000000000000,HMACSHA256=CB735612FD6141213C2827FB5A6A4F4846D7A734" //1000
                                    //123456789012345678901234"; // 1024
                                     "7B15434916FEA6AC16F3D2F2"; // 1024
            auto result = ValidateToken( testToken, sizeof(testToken)  );
            Assert::AreEqual(result, true);
        }
        TEST_METHOD(TokenTooLong)
        {
            // Maximum token length = 1024 bytes
            //                        0000000001111111111222222222233333333334444444444555555555566666666667777777777888888888899999999990
            //                        1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
            char const testToken[] = "NONCE=1,TOKENFORMAT=1,TOKENLENGTH=1025,X=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" // 100
                                     "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222" // 200
                                     "3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333" // 300
                                     "4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444" // 400
                                     "5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555" // 500
                                     "6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666" // 600
                                     "7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777" // 700
                                     "8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888" // 800
                                     "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999" // 900
                                     "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" //1000
                                     "1234567890123456789012345"; // 1025
            auto result = ValidateToken( testToken, sizeof(testToken)  );
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(TokenVeryTooLong)
        {
            // Maximum token length = 1024 bytes
            //                        0000000001111111111222222222233333333334444444444555555555566666666667777777777888888888899999999990
            //                        1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
            char const testToken[] = "NONCE=1,TOKENFORMAT=1,TOKENLENGTH=1025,X=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" // 100
                                     "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222" // 200
                                     "3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333" // 300
                                     "4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444" // 400
                                     "5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555" // 500
                                     "6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666" // 600
                                     "7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777" // 700
                                     "8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888" // 800
                                     "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999" // 900
                                     "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" // 1000
                                     "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111" // 1100
                                     "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222" // 1200
                                     "3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333" // 1300
                                     "4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444" // 1400
                                     "5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555" // 1500
                                     "6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666" // 1600
                                     "7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777" // 1700
                                     "8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888" // 1800
                                     "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999" // 1900
                                     "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" // 2000
                                     "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111" // 2100
                                     "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222" // 2200
                                     "3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333" // 2300
                                     "4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444" // 2400
                                     "5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555" // 2500
                                     "6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666" // 2600
                                     "7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777" // 2700
                                     "8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888" // 2800
                                     "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999" // 2900
                                     "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"; // 2000
            auto result = ValidateToken(testToken, sizeof(testToken));
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(TokenEmptyString)
        {
            char const testToken[] = "";
            auto result = ValidateToken( testToken, sizeof(testToken)  );
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(TokenNull)
        {
            char const *const testToken = nullptr;
            auto result = ValidateToken( testToken, sizeof(testToken)  );
            Assert::AreEqual(result, false);
        }

        TEST_METHOD(KeyNameMissing)
        {
            char const testToken[] = "NONCE=1,=2,TOKENFORMAT=1,TOKENLENGTH=0164,HMACSHA256=CB735612FD6141213C2827FB5A6A4F4846D7A7347B15434916FEA6AC16F3D2F2";
            auto result = ValidateToken(testToken, sizeof(testToken));
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(KeyMissing)
        {
            char const testToken[] = "NONCE=1=2,TOKENFORMAT=1,TOKENLENGTH=0164,HMACSHA256=CB735612FD6141213C2827FB5A6A4F4846D7A7347B15434916FEA6AC16F3D2F2";
            auto result = ValidateToken(testToken, sizeof(testToken));
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(ValueMissing)
        {
            char const testToken[] = "NONCE=,TOKENFORMAT=1,TOKENLENGTH=0164,HMACSHA256=CB735612FD6141213C2827FB5A6A4F4846D7A7347B15434916FEA6AC16F3D2F2";
            auto result = ValidateToken(testToken, sizeof(testToken));
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(KeyEqualsMissing)
        {
            char const testToken[] = "NONCE=1,2,TOKENFORMAT=1,TOKENLENGTH=0164,HMACSHA256=CB735612FD6141213C2827FB5A6A4F4846D7A7347B15434916FEA6AC16F3D2F2";
            auto result = ValidateToken(testToken, sizeof(testToken));
            Assert::AreEqual(result, false);
        }

        TEST_METHOD(NoNonce)
        {
            char const testToken[] = "MISNG=1,TOKENFORMAT=1,TOKENLENGTH=0164,HMACSHA256=CB735612FD6141213C2827FB5A6A4F4846D7A7347B15434916FEA6AC16F3D2F2";
            auto result = ValidateToken(testToken, sizeof(testToken));
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(NoHMAC)
        {
            char const testToken[] = "NONCE=1,TOKENFORMAT=1,TOKENLENGTH=0164,HMACSHA000=CB735612FD6141213C2827FB5A6A4F4846D7A7347B15434916FEA6AC16F3D2F2";
            auto result = ValidateToken(testToken, sizeof(testToken));
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(MACTooSort)
        {
            char const testToken[] = "NONCE=12,TOKENFORMAT=1,TOKENLENGTH=0164,HMACSHA256=CB735612FD6141213C2827FB5A6A4F4846D7A7347B15434916FEA6AC16F3D2F";
            auto result = ValidateToken(testToken, sizeof(testToken));
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(MACNoValue)
        {
            char const testToken[] = "NONCE=12,TOKENFORMAT=1,TOKENLENGTH=0164,VALUE=11111111111111111111111111111111111111111111111111111111,HMACSHA256=";
            auto result = ValidateToken(testToken, sizeof(testToken));
            Assert::AreEqual(result, false);
        }
        TEST_METHOD(MACInvalidKey)
        {
            char const testToken[] = "NONCE=12,TOKENFORMAT=1,TOKENLENGTH=0164,VALUE=111111111111111111111111111111111111111111111111111111111,HMACSHA256";
            auto result = ValidateToken(testToken, sizeof(testToken));
            Assert::AreEqual(result, false);
        }

    };
}
